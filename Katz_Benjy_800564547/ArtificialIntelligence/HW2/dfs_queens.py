"""Results are found at the bottom of the file"""
# -*- coding: utf-8 -*-
"""DFS_queens.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1puD0kHn_0jLIZbtEOzNW4Atp2JNHcaYB

This is the notebook version of the code. I will use this to explain the homework.  
I used parts of the code from: https://www.sanfoundry.com/python-program-solve-n-queen-problem-without-recursion/

As we did in class, we will represent the board as a one-dimensional array where each position in the arrray is the n'th 
queen's column value. So if the array is: [1, 3, 0, 2], then the first queen is in position 1 (from 0--3), the second queen 
is in position 3 (the last column), the third queen is in the first column and the last queen is the in the second position.
"""
import copy
columns = [] #columns is the locations for each of the queens
# columns[r] is a number c if a queen is placed at row r and column c.
size = 8
import random #hint -- you will need this for the following code: column=random.randrange(0,size)

"""Let's setup one iteration of the British Museum algorithm-- we'll put down 4 queens randomly."""
def british_museum(size):
    number_of_moves = size
    number_of_iterations = 1 
    place_n_queens(size)
    while(not(good_solution())):
        number_of_moves+=size
        number_of_iterations+=1
        place_n_queens(size)
    print("Good!")
    display()
    return  number_of_iterations, number_of_moves 

def place_n_queens(size):
    columns.clear()
    row = 0
    while row < size:
        column=random.randrange(0,size)
        columns.append(column)
        row+=1

place_n_queens(size)

"""Now, we can print the result with a simple loop:"""

def display():
    for row in range(len(columns)):
        for column in range(size):
            if column == columns[row]:
                print('â™›', end=' ')
            else:
                print('.', end=' ')
        print()

place_n_queens(size)

display()
print(columns)

"""This of course is not necessary legal, so we'll write a simple DFS search with backtracking:"""

def solve_queen(size):
    columns.clear()
    number_of_moves = 0 #where do I change this so it counts the number of Queen moves?
    number_of_iterations = 0  
    row = 0
    column = 0
    # iterate over rows of board
    while True:
        #place queen in next row
        ''''print(columns)
        print("I have ", row, " number of queens put down")
        display()
        print(number_of_moves)'''
        while column < size:
            number_of_iterations+=1
            number_of_moves+=1
            if next_row_is_safe(column):
                place_in_next_row(column)
                row += 1
                column = 0
                break
            else:
                column += 1
        # if I could not find an open column or if board is full
        if (column == size or row == size):
            number_of_iterations+=1
            number_of_moves+=1
            # if board is full, we have a solution
            if row == size:
                print("I did it! Here is my solution")
                display()
                #print(number_of_moves)
                return number_of_iterations, number_of_moves
            # I couldn't find a solution so I now backtrack
            prev_column = remove_in_current_row()
            if (prev_column == -1): #I backtracked past column 1
                print("There are no solutions")
                #print(number_of_moves)
                return number_of_iterations, number_of_moves
            # try previous row again
            row -= 1
            # start checking at column = (1 + value of column in previous row)
            column = 1 + prev_column

"""This code is nice, but it uses three functions:

1. place_in_next_row

2. remove_in_current_row

3. next_row_is_safe

That we now have to define


"""
def good_solution():
    #check only one per row
    row_set = set()
    for queen_placed in columns: 
        if queen_placed in row_set:
            return False
        row_set.add(queen_placed)
    #check down diagnals
    iter = 0
    for r in range(size):
        num_queens = 0
        diag = 0
        for c in range(size-r):
            if(columns[c+r] == diag):
                num_queens+=1
            if(num_queens>1):
                return False
            diag+=1 
    for r in range(size):
        num_queens = 0
        diag = r
        for c in range(size-r):
            if(columns[c] == diag):
                num_queens+=1
            if(num_queens>1):
                return False
            diag+=1
    #check up diagnals
    for r in range(size):
        num_queens = 0
        diag = r
        for c in range(r+1):
            if(columns[c] == diag):
                num_queens+=1
            if(num_queens>1):
                return False
            diag-=1 
    for r in range(size):
        num_queens = 0
        diag = size-1
        for c in range(size-r):
            if(columns[c+r] == diag):
                num_queens+=1
            if(num_queens>1):
                return False
            diag-=1   
    return True

def solve_forward_checking():
    number_of_iterations = 0
    number_of_moves = 0
    queen = 9
    open = 0
    blocked = 1
    board = [ [0]*size for i in range(size)]
    stack = []
    stack.insert(0, copy.deepcopy(board))   
    new_board = copy.deepcopy(stack[0])
    row = 0
    while(row<size):

        print(stack)
        print(row)
        eligible_col = []
        #find eligible spot
        index = 0
        for spot in new_board[row]:
            if spot == 0:
                eligible_col.append(index)
            index+=1
        #place queen in one of those spots
        rand_col = random.choice(eligible_col)
        print("placing queen")
        new_board[row][rand_col] = queen
        number_of_moves+=1
        number_of_iterations+=1
        if(row == size-1):
            print("We did it")
            for i in range(size):
                for j in range(size):
                    if(new_board[i][j] == queen):columns[i] = j
            for j in range(size):
                if(new_board[size-1][j] == 0): columns[size-1] = j
            display()
            return number_of_iterations, number_of_moves
        #block all lower ineligable
        diag = 1
        for lower_row in range(size-row-1):
            new_board[lower_row+row+1][rand_col] = blocked
            #block diag
            if(rand_col+diag<size):
                new_board[lower_row+row+1][rand_col+diag] = blocked
            if(rand_col-diag>=0):
                new_board[lower_row+row+1][rand_col-diag] = blocked
            diag+=1
        print(new_board)
        #check if next row is full
        if(open in new_board[row+1]):
            stack.insert(0, copy.deepcopy(new_board))
            new_board = copy.deepcopy(stack[0])
            row+=1
        else:
            while(not(open in new_board[row+1])):

                print("poping"+str(row))
                number_of_iterations+=1
                number_of_moves+=1
                prev_queen = -1
                for col in range(size):
                    if(new_board[row][col] == queen):
                        prev_queen = col
                
                #pop
                new_board = stack.pop(0)
                row-=1
                new_board[row+1][prev_queen]=blocked
                print(row) 
                print(new_board)
            stack.insert(0, copy.deepcopy(new_board))
            new_board = copy.deepcopy(stack[0])
            row+=1  


def solve_heuristic_repair():
    number_of_moves = 0
    number_of_iterations = 0
    while(True):
        place_n_queens(size)
        number_of_moves+=8
        number_of_iterations+=1
        new_total_hscore = sum(heuristic_function())
        min = new_total_hscore+1
        while(new_total_hscore < min):
            min = sum(heuristic_function())
            if(min == 0):
                display()
                print("We did it!")
                return number_of_iterations, number_of_moves,
            display()
            row_to_change  = max_row(heuristic_function())
            columns[row_to_change] = best_new_spot(row_to_change)
            number_of_moves+=1
            number_of_iterations+=1
            new_total_hscore = sum(heuristic_function())
        

    #print(row_to_change)
    #print(best_new_spot(row_to_change))

def best_new_spot(row):
    col_hscore = [0]*size
    cur_row = row

    for new_spot in range(size): 

        #print("Cur_row: "+str(cur_row))
        #check above
        row_check = cur_row-1
        while(row_check>=0):
          #  print("row check: "+ str(row_check))
            if columns[row_check] == new_spot:
                col_hscore[new_spot]+=1
            row_check-=1
        #check below
        row_check = cur_row+1
        while(row_check<size):
            if columns[row_check] == new_spot:
                col_hscore[new_spot]+=1
            row_check+=1

        #check both above diag
        row_check = cur_row-1
        iter_above = 1
        while(row_check>=0):
            if (columns[row_check] == new_spot+iter_above or columns[row_check] == new_spot-iter_above):
                col_hscore[new_spot]+=1
               # print("hit above diag")
            iter_above+=1
            row_check-=1

        #check both below diag
        row_check = cur_row+1
        iter_below = 1
        while(row_check<size):
            if (columns[row_check] == new_spot+iter_below or columns[row_check] == new_spot-iter_below ):
                #print("hit below diag")
                col_hscore[new_spot]+=1
            iter_below+=1
            row_check+=1
            
    
    return min_col(col_hscore)
    
def min_col(array):
    min = size+1
    index = 0
    for i in range(size):
        if array[i] < min:
            min = array[i]
            index = i
    return index
def max_row(array):
    max = 0
    index = 0
    print("array: "+ str(array))
    for i in range(size):
        if array[i] > max:
            max = array[i]
            index = i
    return index

def heuristic_function():

    #check only one per row
    total_hscore = 0
    row_hscore = [0]*size
    row_set = set()
    cur_row = 0
    for queen_placed in columns: 
        #print("Cur_row: "+str(cur_row))
        #check above
        row_check = cur_row-1
        while(row_check>=0):
            if columns[row_check] == columns[cur_row]:
                row_hscore[cur_row]+=1
            row_check-=1
        #check below
        row_check = cur_row+1
        while(row_check<size):
            if columns[row_check] == columns[cur_row]:
                row_hscore[cur_row]+=1
            row_check+=1

        #check both above diag
        row_check = cur_row-1
        iter_above = 1
        while(row_check>=0):
            if (columns[row_check] == columns[cur_row]+iter_above or columns[row_check] == columns[cur_row]-iter_above):
                row_hscore[cur_row]+=1
               # print("hit above diag")
            iter_above+=1
            row_check-=1

        #check both below diag
        row_check = cur_row+1
        iter_below = 1
        while(row_check<size):
            if (columns[row_check] == columns[cur_row]+iter_below or columns[row_check] == columns[cur_row]-iter_below ):
                #print("hit below diag")
                row_hscore[cur_row]+=1
            iter_below+=1
            row_check+=1
            
        cur_row+=1
    return row_hscore
        

def place_in_next_row(column):
    columns.append(column)
 
def remove_in_current_row():
    if len(columns) > 0:
        return columns.pop()
    return -1
 
def next_row_is_safe(column):
    row = len(columns) 
    # check column
    for queen_column in columns:
        if column == queen_column:
            return False
 
    # check diagonal
    for queen_row, queen_column in enumerate(columns):
        if queen_column - queen_row == column - row:
            return False
 
    # check other diagonal
    for queen_row, queen_column in enumerate(columns):
        if ((size - queen_column) - queen_row
            == (size - column) - row):
            return False
    return True

#print("Start")
#size = int(input('Enter n: '))
num_iterations=0
number_moves = 0
#for i in range(0, 100):
#    columns = [] #columns is the locations for each of the queens
#num_iterations, number_moves=solve_queen(size)
#print(num_iterations)
#print(columns)

#british_museum(4)
#place_n_queens(8)

print("yay")

total_iterations = 0
total_moves = 0
min_iter = 10000000
max_iter = 0
min_moves = 10000000
max_moves = 0

for i in range(100):
    results = solve_forward_checking()
    if(results[0]>max_iter):
        max_iter = results[0]
    if(results[0]<min_iter):
        min_iter = results[0]
    if(results[1]>max_moves):
        max_moves = results[1]
    if(results[1]<min_moves):
        min_moves = results[1]
    total_iterations+=results[0]
    total_moves+=results[1]
print("Average Iterations: "+str(total_iterations/100))
print("Average moves: "+str(total_moves/100))
print("Min Moves: "+str(min_moves))
print("Max Moves: "+str(max_moves))
print("Min Iter: "+str(min_iter))
print("Max Iter: "+str(max_iter))
"""
British Museum
Average Iterations: 172475.97
Average moves: 1379807.76
Min Moves: 1960
Min Iter: 245
Max Iter: 1329020
Max Moves: 10632160

Heuristic Repair
Average Iterations: 64.53
Average moves: 156.79
Min Moves: 11
Max Moves: 647
Min Iter: 4
Max Iter: 262

DFS
Average Iterations: 982.0
Average moves: 982.0
Min Moves: 982
Max Moves: 982
Min Iter: 982
Max Iter: 982

Forward Checking
Average Iterations: 43.1
Average moves: 43.1
Min Moves: 8
Max Moves: 246
Min Iter: 8
Max Iter: 246

The British museum is clearly the worst algorithm. Even best case it is very unlikely to produce a good score.
DFS is very consistent, it always produces the same result and it is deterministic. If there is a solution it is 
Gaurenteed to find it. However it takes a much longer time. The heuristic method thinks much more humanly just 
to try and put itself in a better situation. It includes an element of randomness to make it more likely to find the 
solution quickly. Forward checking ended up with the best results. it acts like dfs but it can remember where it went
wrong. This too has an element of randomness to allow it to find a solution faster although it loses the determinism.

"""
